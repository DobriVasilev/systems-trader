"""
Core data models for the Trading Systems Engine.

These dataclasses define the fundamental structures used throughout the system.
"""

from dataclasses import dataclass, field
from typing import Optional
from enum import Enum
from datetime import datetime
import pandas as pd


# =============================================================================
# ENUMS
# =============================================================================

class Timeframe(Enum):
    """Supported trading timeframes."""
    M1 = "1m"
    M5 = "5m"
    M15 = "15m"
    M30 = "30m"
    H1 = "1h"
    H4 = "4h"
    D1 = "1d"
    W1 = "1w"

    @property
    def minutes(self) -> int:
        """Return timeframe in minutes."""
        mapping = {
            "1m": 1, "5m": 5, "15m": 15, "30m": 30,
            "1h": 60, "4h": 240, "1d": 1440, "1w": 10080
        }
        return mapping[self.value]


class Direction(Enum):
    """Trade direction."""
    LONG = "long"
    SHORT = "short"


class ExitReason(Enum):
    """Why a trade was closed."""
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    TIME_EXIT = "time_exit"
    TRAILING_STOP = "trailing_stop"
    MANUAL = "manual"
    SIGNAL = "signal"  # Opposite signal


class RangeStatus(Enum):
    """Status of a detected range."""
    ACTIVE = "active"
    BROKEN_UP = "broken_up"
    BROKEN_DOWN = "broken_down"
    EXPIRED = "expired"


# =============================================================================
# CANDLE DATA
# =============================================================================

@dataclass
class CandleData:
    """
    Container for OHLCV candle data.

    Candles are stored as a pandas DataFrame with columns:
    - timestamp (int64): Unix timestamp in milliseconds
    - open (float64)
    - high (float64)
    - low (float64)
    - close (float64)
    - volume (float64)
    """
    asset: str
    timeframe: Timeframe
    candles: pd.DataFrame

    def __post_init__(self):
        """Validate DataFrame structure."""
        required_columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
        for col in required_columns:
            if col not in self.candles.columns:
                raise ValueError(f"Missing required column: {col}")

    def __len__(self) -> int:
        return len(self.candles)

    @property
    def latest(self) -> pd.Series:
        """Get the most recent candle."""
        return self.candles.iloc[-1]

    def get_closes(self) -> pd.Series:
        """Get close prices as Series."""
        return self.candles['close']

    def get_highs(self) -> pd.Series:
        """Get high prices as Series."""
        return self.candles['high']

    def get_lows(self) -> pd.Series:
        """Get low prices as Series."""
        return self.candles['low']


# =============================================================================
# SIGNALS
# =============================================================================

@dataclass
class Signal:
    """
    A trading signal generated by the system.

    If direction is None, there is no signal (hold).
    """
    direction: Optional[Direction] = None
    entry_price: float = 0.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    bar_index: int = 0
    timestamp: int = 0
    reason: str = ""  # Why this signal was generated

    @property
    def has_signal(self) -> bool:
        return self.direction is not None

    @property
    def risk(self) -> float:
        """Calculate risk (entry to stop loss distance)."""
        if self.entry_price == 0 or self.stop_loss == 0:
            return 0.0
        return abs(self.entry_price - self.stop_loss)

    @property
    def reward(self) -> float:
        """Calculate reward (entry to take profit distance)."""
        if self.entry_price == 0 or self.take_profit == 0:
            return 0.0
        return abs(self.take_profit - self.entry_price)

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate R:R ratio."""
        if self.risk == 0:
            return 0.0
        return self.reward / self.risk


# =============================================================================
# TRADES
# =============================================================================

@dataclass
class Trade:
    """
    A completed or open trade.
    """
    id: str
    system_id: str
    asset: str
    direction: Direction

    # Entry
    entry_price: float
    entry_bar: int
    entry_time: datetime

    # Exit (None if still open)
    exit_price: Optional[float] = None
    exit_bar: Optional[int] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[ExitReason] = None

    # Risk management
    stop_loss: float = 0.0
    take_profit: float = 0.0
    position_size: float = 0.0

    # Results (calculated on close)
    pnl_percent: float = 0.0
    pnl_r: float = 0.0
    pnl_usd: float = 0.0

    @property
    def is_open(self) -> bool:
        return self.exit_price is None

    @property
    def is_winner(self) -> bool:
        return self.pnl_r > 0

    def calculate_pnl(self, exit_price: float) -> float:
        """Calculate P&L in R for a given exit price."""
        risk = abs(self.entry_price - self.stop_loss)
        if risk == 0:
            return 0.0

        if self.direction == Direction.LONG:
            profit = exit_price - self.entry_price
        else:
            profit = self.entry_price - exit_price

        return profit / risk


# =============================================================================
# PATTERNS
# =============================================================================

@dataclass
class SwingPoint:
    """A detected swing high or low."""
    bar_index: int
    price: float
    timestamp: int
    is_high: bool  # True = swing high, False = swing low
    touches: list[int] = field(default_factory=list)
    confirmed_at: int = 0
    invalidated_at: Optional[int] = None

    @property
    def is_valid(self) -> bool:
        return self.invalidated_at is None


@dataclass
class FibLevels:
    """Fibonacci retracement levels for a range."""
    level_0: float      # 0% - Range low
    level_236: float    # 23.6%
    level_382: float    # 38.2%
    level_50: float     # 50%
    level_618: float    # 61.8%
    level_75: float     # 75%
    level_786: float    # 78.6%
    level_100: float    # 100% - Range high
    level_neg_20: float # -20% (below range)
    level_120: float    # 120% (above range)

    @classmethod
    def calculate(cls, low: float, high: float) -> 'FibLevels':
        """Calculate all fib levels from low to high."""
        range_size = high - low
        return cls(
            level_0=low,
            level_236=low + range_size * 0.236,
            level_382=low + range_size * 0.382,
            level_50=low + range_size * 0.5,
            level_618=low + range_size * 0.618,
            level_75=low + range_size * 0.75,
            level_786=low + range_size * 0.786,
            level_100=high,
            level_neg_20=low - range_size * 0.2,
            level_120=high + range_size * 0.2,
        )


@dataclass
class Range:
    """A detected consolidation range."""
    start_bar: int
    high: float
    low: float
    high_bar: int
    low_bar: int
    status: RangeStatus = RangeStatus.ACTIVE
    end_bar: Optional[int] = None
    touches_high: list[int] = field(default_factory=list)
    touches_low: list[int] = field(default_factory=list)
    fib_levels: Optional[FibLevels] = None

    def __post_init__(self):
        """Calculate fib levels if not provided."""
        if self.fib_levels is None:
            self.fib_levels = FibLevels.calculate(self.low, self.high)

    @property
    def height(self) -> float:
        return self.high - self.low

    @property
    def midpoint(self) -> float:
        return (self.high + self.low) / 2

    def is_in_discount(self, price: float) -> bool:
        """Check if price is in discount zone (0-25%)."""
        return self.low <= price <= self.fib_levels.level_236

    def is_in_premium(self, price: float) -> bool:
        """Check if price is in premium zone (75-100%)."""
        return self.fib_levels.level_75 <= price <= self.high


@dataclass
class FalseBreakout:
    """A detected false breakout."""
    bar_index: int
    boundary_price: float  # The level that was broken
    wick_extreme: float    # How far the wick went
    close_price: float     # Where it closed
    direction: Direction   # Bullish = wick below, Bearish = wick above
    break_distance: float  # How far beyond the level


@dataclass
class BOS:
    """Break of Structure - trend continuation signal."""
    swing_bar: int
    swing_price: float
    break_bar: int
    break_price: float
    direction: Direction  # Bullish = broke swing high, Bearish = broke swing low


@dataclass
class MSB:
    """Market Structure Break - trend reversal signal."""
    previous_trend: Direction
    swing_bar: int
    swing_price: float
    break_bar: int
    break_price: float
    new_trend: Direction


# =============================================================================
# BACKTEST RESULTS
# =============================================================================

@dataclass
class BacktestResults:
    """Results from a backtest run."""
    system_name: str
    asset: str
    timeframe: str
    start_date: str
    end_date: str

    # Trade counts
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0

    # Win rate
    win_rate: float = 0.0

    # R metrics
    total_r: float = 0.0
    average_r: float = 0.0
    average_winner_r: float = 0.0
    average_loser_r: float = 0.0
    largest_winner_r: float = 0.0
    largest_loser_r: float = 0.0

    # Expectancy
    expectancy: float = 0.0

    # Drawdown
    max_drawdown_r: float = 0.0
    max_drawdown_percent: float = 0.0

    # Streaks
    max_consecutive_wins: int = 0
    max_consecutive_losses: int = 0

    # Direction breakdown
    long_trades: int = 0
    short_trades: int = 0
    long_win_rate: float = 0.0
    short_win_rate: float = 0.0

    # Trade list
    trades: list[Trade] = field(default_factory=list)

    def calculate_from_trades(self, trades: list[Trade]):
        """Calculate all metrics from a list of trades."""
        self.trades = trades
        self.total_trades = len(trades)

        if self.total_trades == 0:
            return

        # Basic counts
        self.winning_trades = sum(1 for t in trades if t.pnl_r > 0)
        self.losing_trades = sum(1 for t in trades if t.pnl_r <= 0)
        self.win_rate = self.winning_trades / self.total_trades

        # R metrics
        r_values = [t.pnl_r for t in trades]
        self.total_r = sum(r_values)
        self.average_r = self.total_r / self.total_trades

        winners = [t.pnl_r for t in trades if t.pnl_r > 0]
        losers = [t.pnl_r for t in trades if t.pnl_r <= 0]

        self.average_winner_r = sum(winners) / len(winners) if winners else 0
        self.average_loser_r = sum(losers) / len(losers) if losers else 0
        self.largest_winner_r = max(winners) if winners else 0
        self.largest_loser_r = min(losers) if losers else 0

        # Expectancy
        self.expectancy = (self.win_rate * self.average_winner_r) + \
                          ((1 - self.win_rate) * self.average_loser_r)

        # Direction breakdown
        long_trades = [t for t in trades if t.direction == Direction.LONG]
        short_trades = [t for t in trades if t.direction == Direction.SHORT]

        self.long_trades = len(long_trades)
        self.short_trades = len(short_trades)
        self.long_win_rate = sum(1 for t in long_trades if t.pnl_r > 0) / len(long_trades) if long_trades else 0
        self.short_win_rate = sum(1 for t in short_trades if t.pnl_r > 0) / len(short_trades) if short_trades else 0

        # Streaks
        self._calculate_streaks(r_values)

        # Drawdown
        self._calculate_drawdown(r_values)

    def _calculate_streaks(self, r_values: list[float]):
        """Calculate winning and losing streaks."""
        if not r_values:
            return

        current_wins = 0
        current_losses = 0

        for r in r_values:
            if r > 0:
                current_wins += 1
                self.max_consecutive_wins = max(self.max_consecutive_wins, current_wins)
                current_losses = 0
            else:
                current_losses += 1
                self.max_consecutive_losses = max(self.max_consecutive_losses, current_losses)
                current_wins = 0

    def _calculate_drawdown(self, r_values: list[float]):
        """Calculate maximum drawdown in R."""
        if not r_values:
            return

        cumulative = 0
        peak = 0

        for r in r_values:
            cumulative += r
            if cumulative > peak:
                peak = cumulative
            drawdown = peak - cumulative
            if drawdown > self.max_drawdown_r:
                self.max_drawdown_r = drawdown

    def summary(self) -> str:
        """Return a formatted summary string."""
        return f"""
Backtest Results: {self.system_name}
{'=' * 50}
Asset: {self.asset} | Timeframe: {self.timeframe}
Period: {self.start_date} to {self.end_date}

Trades: {self.total_trades} ({self.long_trades} long, {self.short_trades} short)
Win Rate: {self.win_rate:.1%}

R Performance:
  Total R: {self.total_r:+.2f}
  Average R: {self.average_r:+.2f}
  Expectancy: {self.expectancy:+.2f}

Winners: {self.winning_trades} (avg {self.average_winner_r:+.2f}R, best {self.largest_winner_r:+.2f}R)
Losers: {self.losing_trades} (avg {self.average_loser_r:+.2f}R, worst {self.largest_loser_r:+.2f}R)

Max Drawdown: {self.max_drawdown_r:.2f}R
Max Win Streak: {self.max_consecutive_wins}
Max Loss Streak: {self.max_consecutive_losses}
"""
