"""
Signal Generator.

Evaluates trading systems against market data to generate trading signals.
Core component that connects systems to execution.
"""

import pandas as pd
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum

from .system_parser import TradingSystem, StopLossType, TakeProfitType
from ..indicators.volatility import atr
from ..patterns.swings import SwingDetector


class SignalType(Enum):
    """Type of trading signal."""
    LONG = "long"
    SHORT = "short"


@dataclass
class Signal:
    """
    A trading signal generated by a system.

    Contains all information needed to execute a trade.
    """
    system_name: str
    signal_type: SignalType
    timestamp: datetime
    symbol: str
    timeframe: str

    # Entry details
    entry_price: float

    # Stop loss and take profit
    stop_loss: float
    take_profit: float

    # Risk calculation
    risk_amount: float  # In price units
    risk_percent: float  # Of account
    reward_risk_ratio: float

    # Position sizing
    position_size: Optional[float] = None

    # Additional context
    conditions_met: List[str] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)

    @property
    def risk_pips(self) -> float:
        """Risk in pips (price difference)."""
        return abs(self.entry_price - self.stop_loss)

    @property
    def reward_pips(self) -> float:
        """Reward in pips."""
        return abs(self.take_profit - self.entry_price)


class SignalGenerator:
    """
    Generates trading signals by evaluating systems against market data.

    Core workflow:
    1. Load candle data
    2. Evaluate each system's entry conditions
    3. Calculate stop loss and take profit
    4. Generate Signal if conditions met
    """

    def __init__(
        self,
        systems: List[TradingSystem] = None,
        default_atr_period: int = 14,
    ):
        """
        Initialize Signal Generator.

        Args:
            systems: List of trading systems to evaluate
            default_atr_period: ATR period for SL/TP calculations
        """
        self.systems = systems or []
        self.default_atr_period = default_atr_period
        self.swing_detector = SwingDetector()

    def add_system(self, system: TradingSystem):
        """Add a trading system to evaluate."""
        self.systems.append(system)

    def generate_signals(
        self,
        candles: pd.DataFrame,
        symbol: str,
        account_balance: float = 10000.0,
        **context
    ) -> List[Signal]:
        """
        Generate signals from all systems for current candle data.

        Args:
            candles: OHLCV DataFrame
            symbol: Trading symbol
            account_balance: Account balance for position sizing
            **context: Additional context to pass to conditions

        Returns:
            List of Signal objects
        """
        signals = []

        for system in self.systems:
            if not system.enabled:
                continue

            signal = self._evaluate_system(
                system=system,
                candles=candles,
                symbol=symbol,
                account_balance=account_balance,
                **context
            )

            if signal:
                signals.append(signal)

        return signals

    def _evaluate_system(
        self,
        system: TradingSystem,
        candles: pd.DataFrame,
        symbol: str,
        account_balance: float,
        **context
    ) -> Optional[Signal]:
        """
        Evaluate a single system against candle data.

        Returns Signal if entry conditions met, None otherwise.
        """
        # Check direction filter
        # (For now, system.direction determines signal type)

        # Check entry conditions
        if not system.check_entry(candles, **context):
            return None

        # Entry conditions met - generate signal
        current_price = candles['close'].iloc[-1]
        timestamp = datetime.now()
        if 'timestamp' in candles.columns:
            timestamp = pd.to_datetime(candles['timestamp'].iloc[-1])

        # Determine signal type based on system direction
        if system.direction == 'long':
            signal_type = SignalType.LONG
        elif system.direction == 'short':
            signal_type = SignalType.SHORT
        else:
            # 'both' - would need additional logic to determine
            # For now, default to long
            signal_type = SignalType.LONG

        # Calculate stop loss
        stop_loss = self._calculate_stop_loss(
            candles=candles,
            config=system.stop_loss,
            signal_type=signal_type,
            entry_price=current_price,
        )

        # Calculate risk
        risk_amount = abs(current_price - stop_loss)
        risk_percent = system.risk_percent

        # Calculate take profit
        take_profit = self._calculate_take_profit(
            candles=candles,
            config=system.take_profit,
            signal_type=signal_type,
            entry_price=current_price,
            stop_loss=stop_loss,
            risk_amount=risk_amount,
        )

        # Calculate R:R
        reward_amount = abs(take_profit - current_price)
        reward_risk_ratio = reward_amount / risk_amount if risk_amount > 0 else 0

        # Calculate position size
        risk_dollar = account_balance * (risk_percent / 100)
        position_size = risk_dollar / risk_amount if risk_amount > 0 else 0

        # Collect condition details
        conditions_met = [c.name for c in system.entry_conditions]

        return Signal(
            system_name=system.name,
            signal_type=signal_type,
            timestamp=timestamp,
            symbol=symbol,
            timeframe=system.timeframe,
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            risk_amount=risk_amount,
            risk_percent=risk_percent,
            reward_risk_ratio=reward_risk_ratio,
            position_size=position_size,
            conditions_met=conditions_met,
            context={
                'account_balance': account_balance,
                'risk_dollar': risk_dollar,
            }
        )

    def _calculate_stop_loss(
        self,
        candles: pd.DataFrame,
        config,  # StopLossConfig
        signal_type: SignalType,
        entry_price: float,
    ) -> float:
        """Calculate stop loss price based on configuration."""
        if config.type == StopLossType.ATR:
            atr_values = atr(candles, period=self.default_atr_period)
            atr_value = atr_values.iloc[-1]
            offset = atr_value * config.value

            if signal_type == SignalType.LONG:
                return entry_price - offset
            else:
                return entry_price + offset

        elif config.type == StopLossType.PERCENT:
            offset = entry_price * (config.value / 100)
            if signal_type == SignalType.LONG:
                return entry_price - offset
            else:
                return entry_price + offset

        elif config.type == StopLossType.FIXED:
            if signal_type == SignalType.LONG:
                return entry_price - config.value
            else:
                return entry_price + config.value

        elif config.type == StopLossType.SWING:
            # Use recent swing low (for long) or swing high (for short)
            swings = self.swing_detector.detect_major_swings(candles)
            if signal_type == SignalType.LONG:
                lows = [s for s in swings if s.is_low()]
                if lows:
                    return lows[-1].price
            else:
                highs = [s for s in swings if s.is_high()]
                if highs:
                    return highs[-1].price

            # Fallback to ATR
            atr_values = atr(candles, period=self.default_atr_period)
            offset = atr_values.iloc[-1] * 1.5
            return entry_price - offset if signal_type == SignalType.LONG else entry_price + offset

        elif config.type == StopLossType.LEVEL:
            # Would need level from context
            # Fallback to ATR
            atr_values = atr(candles, period=self.default_atr_period)
            offset = atr_values.iloc[-1] * 1.5
            return entry_price - offset if signal_type == SignalType.LONG else entry_price + offset

        # Default fallback
        atr_values = atr(candles, period=self.default_atr_period)
        offset = atr_values.iloc[-1] * 1.5
        return entry_price - offset if signal_type == SignalType.LONG else entry_price + offset

    def _calculate_take_profit(
        self,
        candles: pd.DataFrame,
        config,  # TakeProfitConfig
        signal_type: SignalType,
        entry_price: float,
        stop_loss: float,
        risk_amount: float,
    ) -> float:
        """Calculate take profit price based on configuration."""
        if config.type == TakeProfitType.RISK_REWARD:
            reward = risk_amount * config.value
            if signal_type == SignalType.LONG:
                return entry_price + reward
            else:
                return entry_price - reward

        elif config.type == TakeProfitType.ATR:
            atr_values = atr(candles, period=self.default_atr_period)
            atr_value = atr_values.iloc[-1]
            offset = atr_value * config.value

            if signal_type == SignalType.LONG:
                return entry_price + offset
            else:
                return entry_price - offset

        elif config.type == TakeProfitType.PERCENT:
            offset = entry_price * (config.value / 100)
            if signal_type == SignalType.LONG:
                return entry_price + offset
            else:
                return entry_price - offset

        elif config.type == TakeProfitType.FIXED:
            if signal_type == SignalType.LONG:
                return entry_price + config.value
            else:
                return entry_price - config.value

        elif config.type == TakeProfitType.LEVEL:
            # Would need level from context (e.g., range high)
            # Fallback to 3R
            reward = risk_amount * 3.0
            return entry_price + reward if signal_type == SignalType.LONG else entry_price - reward

        # Default fallback - 3R
        reward = risk_amount * 3.0
        return entry_price + reward if signal_type == SignalType.LONG else entry_price - reward


@dataclass
class SystemEvaluation:
    """Result of evaluating a system (for debugging/logging)."""
    system_name: str
    all_conditions_met: bool
    condition_results: Dict[str, bool]
    signal_generated: bool
    signal: Optional[Signal] = None


class DebugSignalGenerator(SignalGenerator):
    """
    Signal generator with detailed debugging output.

    Useful for understanding why signals are or aren't generated.
    """

    def evaluate_with_debug(
        self,
        candles: pd.DataFrame,
        symbol: str,
        account_balance: float = 10000.0,
        **context
    ) -> List[SystemEvaluation]:
        """
        Evaluate all systems with detailed debugging info.

        Returns list of SystemEvaluation with per-condition results.
        """
        evaluations = []

        for system in self.systems:
            condition_results = {}

            # Evaluate each condition
            for condition in system.entry_conditions:
                result = condition.evaluate(candles, **context)
                condition_results[condition.name] = result.is_true()

            # Check filters
            filter_results = {}
            for filter_cond in system.filters:
                result = filter_cond.evaluate(candles, **context)
                filter_results[filter_cond.name] = result.is_true()

            all_conditions_met = all(condition_results.values())
            filters_passed = not system.filters or any(filter_results.values())

            signal = None
            if all_conditions_met and filters_passed:
                signal = self._evaluate_system(
                    system=system,
                    candles=candles,
                    symbol=symbol,
                    account_balance=account_balance,
                    **context
                )

            evaluations.append(SystemEvaluation(
                system_name=system.name,
                all_conditions_met=all_conditions_met and filters_passed,
                condition_results={**condition_results, **filter_results},
                signal_generated=signal is not None,
                signal=signal,
            ))

        return evaluations


# =============================================================================
# FACTORY FUNCTIONS
# =============================================================================

def create_signal_generator(systems: List[TradingSystem] = None) -> SignalGenerator:
    """Create a signal generator with optional systems."""
    return SignalGenerator(systems=systems)


def generate_signals(
    systems: List[TradingSystem],
    candles: pd.DataFrame,
    symbol: str,
    account_balance: float = 10000.0
) -> List[Signal]:
    """Quick function to generate signals from systems."""
    generator = SignalGenerator(systems=systems)
    return generator.generate_signals(candles, symbol, account_balance)
